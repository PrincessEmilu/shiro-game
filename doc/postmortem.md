# Shiro Postmortem

Our team of Game Design and Development (GDD) students in a first year course at Rochester Institute of Technology (RIT) first met in February.
Knowing very little about each other or about working on a large game project as a team, we didn't know exactly what to expect from our project. After
talking about the various genres we wanted to work on, we came up with the idea of a story-driven game about a cat wanting to get home. Initially, we had
concerns about scope of the project, but we were convinced that we would learn a lot about game development could create something unique if we went forward
with our idea of the lost cat facing his fears on a journey home.

When we started actually coding together at the start of milestone 2, things seemed to be going smoothly for us. We each worked independently on different classes 
and mechanics that we were interested in individually. At first, it seemed like this was a very efficient way to get a lot done. While it certainly was efficient, we 
slowly started to run into some issues with our various pieces of the game actually fitting together. At some points, this caused us a lot of frustration with trying 
to force the pieces together. What had seemed in the beginning to be a simple plan quickly became more complex, due to both our newness with programming in C# and due 
to working on a group coding project, which was unlike anything we had done last semester, or in other classes. Because we had to deal with this difficulty, Shiro 
slowly evolved in how we implemented classes and mechanics from how we originally planned. This evolution however was not strictly negative- new ideas and features 
revealed themselves to us as we continue to code and playtest, and the Shiro we have ended up with is not the same Shiro we started with in our minds.

## What Went Right:

Participation
On top of Milestone Requirements
Everyone was heard

Art Style

External Tools

## What Went Wrong:

Messy Code
Coordinating code
Quick Fixes

Prioritizing

Architecture

## What We Learned:
Working as a group, while having it's benefits, also has some things that we never considered that could be an issue. While we all worked together wonderfully, group
work is still different than personal work. We all came in with different strengths and weakness, and (while not that much of this happened) had to adapt to each other's
knowledge and coding styles. Group work also consisted of a lot of conversation of when to push set code, because we had a lot of conflicts at many points in a project. 
At one point, we lost a whole days' worth of work because of lack of communication and double checking if everything merged right! Another thing that we realized as we were
coding Shiro, was that Architecture is more important than we planned it to be. 

While we were on top of most of the documents in our Git repo, one of the documents we slacked a bit on was updating our Architecture diagrams. This, in turn, made it somewhat
difficult for teammates to code other portions of code they didn't write, just because whoever was working on it new didn't realize that there were set variables/methods already
made for something they were coding. Architecture was also important for laying out all of our inheritance, which was constantly changing because we didn't sit down and make the
architecture diagrams for all of our enemies and bosses correctly.

Finally, the most important thing that we learned is that the response of playtesting is important! While we are masters at our own game because we coded it, we realized that for
some people during playtesting that Shiro was difficult for set age groups. Something that also came into light was that the story of the game (and why Shiro is fighting weird monsters)
was lost to some people because we only showed it on the instructions screen. While we don't have time to make a introduction to the game or add context in story format, the factor of 
the game being difficult to younger demographics is something we should of thought about during our group conversations and planning. Playtesting and getting feedback also was beneficial
for our group because it boosted our confidence in our game, and we practiced a lot of skills that we would need to use later on in our careers and college game making lives.
## What We Would Do Differently:
 
Explaining our code to each other more effectively

Plan out architecture better

Organization - tasks - use trello more

Used Data Structures More Effciently - Design Patterns 

## Conclusion

Insert Conclusion Here