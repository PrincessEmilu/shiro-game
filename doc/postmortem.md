# Shiro Postmortem

Our team of Game Design and Development (GDD) students in a first year course at Rochester Institute of Technology (RIT) first met in February.
Knowing very little about each other or about working on a large game project as a team, we didn't know exactly what to expect from our project. After
talking about the various genres we wanted to work on, we came up with the idea of a story-driven game about a cat wanting to get home. Initially, we had
concerns about scope of the project, but we were convinced that we would learn a lot about game development could create something unique if we went forward
with our idea of the lost cat facing his fears on a journey home.

When we started actually coding together at the start of milestone 2, things seemed to be going smoothly for us. We each worked independently on different classes 
and mechanics that we were interested in individually. At first, it seemed like this was a very efficient way to get a lot done. While it certainly was efficient, we 
slowly started to run into some issues with our various pieces of the game actually fitting together. At some points, this caused us a lot of frustration with trying 
to force the pieces together. What had seemed in the beginning to be a simple plan quickly became more complex, due to both our newness with programming in C# and due 
to working on a group coding project, which was unlike anything we had done last semester, or in other classes. Because we had to deal with this difficulty, Shiro 
slowly evolved in how we implemented classes and mechanics from how we originally planned. This evolution however was not strictly negative- new ideas and features 
revealed themselves to us as we continue to code and playtest, and the Shiro we have ended up with is not the same Shiro we started with in our minds.

## What Went Right:

Participation
On top of Milestone Requirements
Everyone was heard

Art Style

External Tools

## What Went Wrong:

Messy Code
Coordinating code
Quick Fixes

Prioritizing

Architecture

## What We Learned:
Working as a group, while having it's benefits, also has some things that we never considered that could be an issue. While we all worked together wonderfully, group
work is still different than personal work. We all came in with different strengths and weakness, and (while not that much of this happened) had to adapt to each other's
knowledge and coding styles. Group work also consisted of a lot of conversation of when to push set code, because we had a lot of conflicts at many points in a project. 
At one point, we lost a whole days' worth of work because of lack of communication and double checking if everything merged right! Another thing that we realized as we were
coding Shiro, was that Architecture is more important than we planned it to be. 

While we were on top of most of the documents in our Git repo, one of the documents we slacked a bit on was updating our Architecture diagrams. This, in turn, made it somewhat
difficult for teammates to code other portions of code they didn't write, just because whoever was working on it new didn't realize that there were set variables/methods already
made for something they were coding. Architecture was also important for laying out all of our inheritance, which was constantly changing because we didn't sit down and make the
architecture diagrams for all of our enemies and bosses correctly.

Finally, the most important thing that we learned is that the response of playtesting is important! While we are masters at our own game because we coded it, we realized that for
some people during playtesting that Shiro was difficult for set age groups. Something that also came into light was that the story of the game (and why Shiro is fighting weird monsters)
was lost to some people because we only showed it on the instructions screen. While we don't have time to make a introduction to the game or add context in story format, the factor of 
the game being difficult to younger demographics is something we should of thought about during our group conversations and planning. Playtesting and getting feedback also was beneficial
for our group because it boosted our confidence in our game, and we practiced a lot of skills that we would need to use later on in our careers and college game making lives.
## What We Would Do Differently:
 
There are many things that we would do differently if we could restart this project. One of them being the fact that we would take more time out of our meetings to sit down and
explain to each other what our code means and why we chose to implement something in the way that we chose. This was a big thing that caused confusion and is necessary for any
future projects that we may work on. It will help us learn more, and improve the project better by having a better understanding. Another thing that we would definitely change 
is our plans for architecture. Planning our the architecture was not as strong as we would like and we see it as something that we would change. We saw many times that we were
making changes to it as we went along. A better plan at the start would cut down changes and would give us a better idea of how to move forward.

Another thing that was lacking that could have been improved on was our method of organization and division of tasks. We had a solid idea for the use of Trello within our project
but we see that it could have been more effective. First of all, we did not fully use it until part way through the project, using it from the very beginning would have helped
a lot more than starting it part way through. Another thing with Trello is that we could have used it more by assigning certain tasks to people more often or creating more cards
on the board that kept track of things. The method of how we used it was good, the problem falls with how often it was being used by everyone and that is what should be changed.
One last thing would be to use data structures more often and efficiently. We used some of them in certain parts of the project but looking back at it, we see that there could
have been more use for them. Having the knowledge that we do now, we would have certainly used them more to clean up our code better and keep things more tidy and more efficient.

There were definite changes that we would have made if we knew what we knew now. We still succeeded in our project but we still could have been even more efficient with better
tactics to solve problems.

## Conclusion

Insert Conclusion Here